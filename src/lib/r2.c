#include <hbc/hbc.h>
#include <hbc/parser.h>

/* Generate r2 script with function flags - robust version inspired by the Python implementation */
Result hbc_generate_r2_script(const char *input_file, const char *output_file) {
	if (!input_file) {
		return ERROR_RESULT (RESULT_ERROR_INVALID_ARGUMENT, "Input file is NULL");
	}

	/* Initialize HBC reader */
	HBCReader reader;
	Result result = hbc_reader_init (&reader);
	if (result.code != RESULT_SUCCESS) {
		return result;
	}

	/* Read and parse the file */
	result = hbc_reader_read_file (&reader, input_file);
	if (result.code != RESULT_SUCCESS) {
		fprintf (stderr, "Error reading file: %s\n", result.error_message);
		hbc_reader_cleanup (&reader);
		return result;
	}

	/* Parse header and function info */
	result = hbc_reader_read_header (&reader);
	if (result.code != RESULT_SUCCESS) {
		fprintf (stderr, "Error reading header: %s\n", result.error_message);
		hbc_reader_cleanup (&reader);
		return result;
	}

	/* Open output file early so we can at least output basic info even if function parsing fails */
	FILE *out = stdout;
	if (output_file) {
		out = fopen (output_file, "w");
		if (!out) {
			fprintf (stderr, "Error opening output file: %s\n", output_file);
			hbc_reader_cleanup (&reader);
			return ERROR_RESULT (RESULT_ERROR_FILE_NOT_FOUND, "Failed to open output file");
		}
	}

	/* Generate r2 script header */
	fprintf (out, "# R2 script for Hermes bytecode file: %s\n", input_file);
	fprintf (out, "# Generated by libhbctool\n\n");

	/* Add basic file info as comments */
	fprintf (out, "# Hermes File Version: %u\n", reader.header.version);
	fprintf (out, "# File Size: %u bytes\n", reader.header.fileLength);
	fprintf (out, "# Function Count: %u\n\n", reader.header.functionCount);

	/* Create flag for HBC header */
	fprintf (out, "# Basic file structure flags\n");
	fprintf (out, "f hbc.header=0x0\n");
	fprintf (out, "f hbc.header.size=0x%lx\n", (unsigned long)sizeof (HBCHeader));

	/* ================= ROBUST FUNCTION PARSING ================= */

	/* Align buffer */
	result = buffer_reader_align (&reader.file_buffer, 4);
	if (result.code != RESULT_SUCCESS) {
		fprintf (stderr, "Warning: Error aligning buffer for functions: %s\n", result.error_message);
		fprintf (out, "# Warning: Error aligning buffer for functions: %s\n", result.error_message);
		hbc_reader_cleanup (&reader);
		return SUCCESS_RESULT (); /* Return success since we've written what we can */
	}

	/* Set reasonable limits for function count */
	const u32 MAX_SAFE_FUNCTIONS = 50000;
	u32 function_count = reader.header.functionCount;

	if (function_count > MAX_SAFE_FUNCTIONS) {
		fprintf (stderr, "Warning: Very large function count (%u). Limiting to %u for safety.\n",
			reader.header.functionCount, MAX_SAFE_FUNCTIONS);
		function_count = MAX_SAFE_FUNCTIONS;
	}

	fprintf (stderr, "Reading functions at position %zu of %zu bytes.\n",
		reader.file_buffer.position, reader.file_buffer.size);
	fprintf (out, "# Reading %u functions from position 0x%zx\n",
		function_count, reader.file_buffer.position);

	/* Check for reasonable function count vs file size */
	size_t min_bytes_needed = function_count * 16; /* Each header is at least 16 bytes */
	if (reader.file_buffer.position + min_bytes_needed > reader.file_buffer.size) {
		fprintf (stderr, "Warning: File might be truncated. Need ~%zu more bytes for function headers.\n",
			min_bytes_needed);
		fprintf (out, "# Warning: File appears too small for %u functions, may only read partial data\n",
			function_count);
	}

	/* Create temporary array for function names to solve temp_name lifetime issues */
	char **function_names = (char **)calloc (function_count, sizeof (char *));
	if (!function_names) {
		fprintf (stderr, "Error: Failed to allocate memory for function names\n");
		if (output_file) {
			fclose (out);
		}
		hbc_reader_cleanup (&reader);
		return ERROR_RESULT (RESULT_ERROR_MEMORY_ALLOCATION, "Failed to allocate function names");
	}

	/* Initialize all function names to NULL */
	for (u32 i = 0; i < function_count; i++) {
		function_names[i] = NULL;
	}

	/* Track functions we read successfully */
	size_t successful_functions = 0;
	u32 *function_offsets = (u32 *)calloc (function_count, sizeof (u32));
	u32 *function_sizes = (u32 *)calloc (function_count, sizeof (u32));

	if (!function_offsets || !function_sizes) {
		fprintf (stderr, "Error: Failed to allocate memory for function offsets or sizes\n");
		free (function_names);
		free (function_offsets);
		free (function_sizes);
		if (output_file) {
			fclose (out);
		}
		hbc_reader_cleanup (&reader);
		return ERROR_RESULT (RESULT_ERROR_MEMORY_ALLOCATION, "Failed to allocate memory");
	}

	/* Print current position in case we have issues */
	fprintf (stderr, "Function section start position: %zu\n", reader.file_buffer.position);

	/* Read all function headers directly from the buffer */
	for (u32 i = 0; i < function_count; i++) {
		/* Safety check - ensure we have enough buffer for a function header (16 bytes) */
		if (reader.file_buffer.position + 16 > reader.file_buffer.size) {
			fprintf (stderr, "Reached end of file after reading %zu of %u functions\n",
				successful_functions, function_count);
			break; /* End reading if we reach end of buffer */
		}

		/* Track position in case we need to restore it */
		size_t start_position = reader.file_buffer.position;

		/* Read function header raw data with explicit error handling */
		u32 raw_data[4];
		bool header_read_failed = false;

		for (int j = 0; j < 4; j++) {
			Result res = buffer_reader_read_u32 (&reader.file_buffer, &raw_data[j]);
			if (res.code != RESULT_SUCCESS) {
				fprintf (stderr, "Error reading function %u header word %d: %s\n",
					i, j, res.error_message);
				header_read_failed = true;
				break;
			}
		}

		if (header_read_failed) {
			/* Restore position and break */
			buffer_reader_seek (&reader.file_buffer, start_position);
			break;
		}

		/* Extract fields from raw data based on the Python implementation */
		u32 offset = raw_data[0] & 0x1FFFFFF; /* 25 bits */
		/* Unused: u32 paramCount = (raw_data[0] >> 25) & 0x7F; */

		u32 bytecodeSizeInBytes = raw_data[1] & 0x7FFF; /* 15 bits */
		/* Unused: u32 functionName = (raw_data[1] >> 15) & 0x1FFFF; */

		/* Unused:
		u32 infoOffset = raw_data[2] & 0x1FFFFFF;
		u32 frameSize = (raw_data[2] >> 25) & 0x7F;

		u8 flags = (u8) ((raw_data[3] >> 24) & 0xFF);
		bool overflowed = (flags >> 5) & 0x1;
		 */

		/* Skip if offset is invalid or outside file bounds */
		if (offset == 0 || offset >= reader.file_buffer.size) {
			/* Skip this function silently */
			continue;
		}

		/* Store offset and size for flag generation */
		function_offsets[successful_functions] = offset;
		function_sizes[successful_functions] = bytecodeSizeInBytes;

		/* Generate a default function name based on index */
		char *temp_name = (char *)malloc (32);
		if (temp_name) {
			snprintf (temp_name, 32, "func_%u", i);
			function_names[successful_functions] = temp_name;
		}

		successful_functions++;
	}

	fprintf (stderr, "Successfully read %zu function headers\n", successful_functions);
	fprintf (out, "# Successfully read %zu function headers\n\n", successful_functions);

	/* ==== READ STRING TABLES AND CREATE STRING FLAGS ==== */
	/* Structure to store string info temporarily */
	typedef struct {
		u32 offset; /* Offset in string storage */
		u32 length; /* Length of string */
		bool isUTF16; /* Whether the string is UTF-16 encoded */
	} StringInfo;

	StringInfo *string_infos = NULL;
	u8 *string_storage = NULL;
	size_t string_storage_size = 0;

	/* Output function flags */
	fprintf (out, "# Function flags\n");
	for (size_t i = 0; i < successful_functions; i++) {
		/* Use function names we generated earlier */
		const char *function_name = function_names[i]? function_names[i]: "unknown";

		/* Generate sanitized name for r2 */
		char sanitized_name[256] = { 0 };
		size_t name_len = strlen (function_name);
		size_t sanitized_idx = 0;

		for (size_t j = 0; j < name_len && sanitized_idx < sizeof (sanitized_name) - 1; j++) {
			char c = function_name[j];
			if ((c >= 'a' && c <= 'z') ||
				(c >= 'A' && c <= 'Z') ||
				(c >= '0' && c <= '9') ||
				c == '_') {
				sanitized_name[sanitized_idx++] = c;
			} else {
				sanitized_name[sanitized_idx++] = '_';
			}
		}
		sanitized_name[sanitized_idx] = '\0';

		/* If sanitized name is empty, use a default */
		if (sanitized_name[0] == '\0') {
			snprintf (sanitized_name, sizeof (sanitized_name), "func_%zu", i);
		}

		/* Write the function flag */

		/* Add size info if available */
		if (function_sizes[i] > 0) {
			fprintf (out, "'f func.hermes.%s 0x%x 0x%x\n", sanitized_name,
				function_sizes[i], function_offsets[i]);
		} else {
			fprintf (out, "'f func.hermes.%s=0x%x\n", sanitized_name, function_offsets[i]);
		}
	}

	/* Now try to parse string tables based on Python implementation */
	fprintf (out, "\n# String flags\n");
	bool strings_parsed = false;

	/* First try to locate and read the string tables */
	/* Reset file position */
	if (buffer_reader_seek (&reader.file_buffer, sizeof (HBCHeader)).code == RESULT_SUCCESS) {
		/* Skip over functions section */
		u32 function_headers_bytes = reader.header.functionCount * 16; /* 16 bytes per small header */
		result = buffer_reader_seek (&reader.file_buffer, reader.file_buffer.position + function_headers_bytes);

		if (result.code == RESULT_SUCCESS) {
			/* Align for string kinds */
			result = buffer_reader_align (&reader.file_buffer, 4);
			if (result.code == RESULT_SUCCESS) {
				/* Skip over string kinds section */
				if (reader.header.stringKindCount > 0) {
					result = buffer_reader_seek (&reader.file_buffer,
						reader.file_buffer.position + reader.header.stringKindCount * sizeof (u32));
				}

				if (result.code == RESULT_SUCCESS) {
					/* Skip over identifier hashes section */
					if (reader.header.identifierCount > 0) {
						result = buffer_reader_align (&reader.file_buffer, 4);
						if (result.code == RESULT_SUCCESS) {
							result = buffer_reader_seek (&reader.file_buffer,
								reader.file_buffer.position + reader.header.identifierCount * sizeof (u32));
						}
					}

					if (result.code == RESULT_SUCCESS) {
						/* Prepare to read string tables */
						result = buffer_reader_align (&reader.file_buffer, 4);

						if (result.code == RESULT_SUCCESS && reader.header.stringCount > 0) {
							fprintf (stderr, "Reading string tables at position %zu\n", reader.file_buffer.position);

							/* Allocate storage for string info */
							u32 safe_string_count = reader.header.stringCount;
							if (safe_string_count > 100000) {
								safe_string_count = 100000; /* Safety limit */
							}

							string_infos = (StringInfo *)calloc (safe_string_count, sizeof (StringInfo));
							if (!string_infos) {
								fprintf (stderr, "Failed to allocate memory for string infos\n");
							} else {
								/* Read the small string table entries */
								bool read_success = true;
								for (u32 i = 0; i < safe_string_count; i++) {
									u32 entry;
									result = buffer_reader_read_u32 (&reader.file_buffer, &entry);
									if (result.code != RESULT_SUCCESS) {
										read_success = false;
										break;
									}

									/* Parse entry fields */
									string_infos[i].isUTF16 = entry & 0x1;
									string_infos[i].offset = (entry >> 1) & 0x7FFFFF; /* 23 bits */
									string_infos[i].length = (entry >> 24) & 0xFF; /* 8 bits */
								}

								/* Skip overflow string table if present */
								if (read_success && reader.header.overflowStringCount > 0) {
									result = buffer_reader_align (&reader.file_buffer, 4);
									if (result.code == RESULT_SUCCESS) {
										/* Skip past each overflow entry (8 bytes each) */
										result = buffer_reader_seek (&reader.file_buffer,
											reader.file_buffer.position + reader.header.overflowStringCount * 8);
									}
								}

								/* Now read the actual string data */
								if (read_success && result.code == RESULT_SUCCESS) {
									/* Align buffer for string storage */
									result = buffer_reader_align (&reader.file_buffer, 4);
									if (result.code == RESULT_SUCCESS && reader.header.stringStorageSize > 0) {
										/* Safety check - limit large string storage */
										size_t storage_size = reader.header.stringStorageSize;
										if (storage_size > 10 * 1024 * 1024) { /* 10MB limit */
											storage_size = 10 * 1024 * 1024;
										}

										/* Make sure we have room to read */
										if (reader.file_buffer.position + storage_size <= reader.file_buffer.size) {
											/* Allocate space for string storage */
											string_storage = (u8 *)malloc (storage_size);
											if (string_storage) {
												/* Read entire string storage section */
												result = buffer_reader_read_bytes (&reader.file_buffer, string_storage, storage_size);
												if (result.code == RESULT_SUCCESS) {
													string_storage_size = storage_size;
													strings_parsed = true;
													fprintf (stderr, "Successfully read %zu bytes of string data\n", storage_size);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	/* Generate string flags if we managed to read the string data */
	if (strings_parsed && string_infos && string_storage) {
		u32 safe_string_count = reader.header.stringCount;
		if (safe_string_count > 100000) {
			safe_string_count = 100000;
		}

		/* Create flags for each string */
		u32 successful_strings = 0;
		for (u32 i = 0; i < safe_string_count; i++) {
			u32 offset = string_infos[i].offset;
			u32 length = string_infos[i].length;
			bool isUTF16 = string_infos[i].isUTF16;

			/* Skip strings with obviously invalid offsets/lengths */
			if (offset >= string_storage_size ||
				(isUTF16 && offset + (length * 2) > string_storage_size) ||
				(!isUTF16 && offset + length > string_storage_size)) {
				continue;
			}

			/* For very long strings, truncate for flag name purposes */
			u32 display_length = length;
			if (display_length > 32) {
				display_length = 32;
			}

			/* Generate a string value for the flag name */
			char str_value[64] = { 0 };
			if (isUTF16) {
				/* UTF-16 string - simplified handling */
				u32 chars_added = 0;
				for (u32 j = 0; j < display_length && chars_added < sizeof (str_value) - 1; j++) {
					/* Read 16-bit character */
					u16 c = (u16) (string_storage[offset + (j * 2)] | (string_storage[offset + (j * 2) + 1] << 8));

					/* Only add ASCII-printable characters to name */
					if (c >= 32 && c < 127) {
						str_value[chars_added++] = (char)c;
					} else {
						str_value[chars_added++] = '_';
					}
				}
				str_value[chars_added] = '\0';
			} else {
				/* ASCII string */
				u32 chars_added = 0;
				for (u32 j = 0; j < display_length && chars_added < sizeof (str_value) - 1; j++) {
					char c = (char)string_storage[offset + j];

					/* Only add printable characters to name */
					if (c >= 32 && c < 127) {
						str_value[chars_added++] = c;
					} else {
						str_value[chars_added++] = '_';
					}
				}
				str_value[chars_added] = '\0';
			}

			/* Generate sanitized name for r2 - only include alphanumeric and underscores */
			char sanitized_name[64] = { 0 };
			size_t name_len = strlen (str_value);
			size_t sanitized_idx = 0;

			for (size_t j = 0; j < name_len && sanitized_idx < sizeof (sanitized_name) - 1; j++) {
				char c = str_value[j];
				if ((c >= 'a' && c <= 'z') ||
					(c >= 'A' && c <= 'Z') ||
					(c >= '0' && c <= '9') ||
					c == '_') {
					sanitized_name[sanitized_idx++] = c;
				} else {
					sanitized_name[sanitized_idx++] = '_';
				}
			}
			sanitized_name[sanitized_idx] = '\0';

			/* Add index to name to ensure uniqueness */
			char unique_name[96];
			snprintf (unique_name, sizeof (unique_name), "%s_%u",
				sanitized_name[0]? sanitized_name: "str", i);

			/* Write the string flag - offset is relative to string storage base */
			uint32_t size = (isUTF16)? length * 2: length;
			uint32_t addr = (unsigned long) (reader.file_buffer.position - string_storage_size + offset);
			fprintf (out, "'f str.%s %d 0x%08x\n", unique_name, size, addr);
#if 0
	/* Add flag for string length */
	if (isUTF16) {
		fprintf (out, "f str.%s.size=0x%x\n", unique_name, length * 2);
	} else {
		fprintf (out, "f str.%s.size=0x%x\n", unique_name, length);
	}
#endif

			successful_strings++;
		}

		fprintf (stderr, "Generated flags for %u strings\n", successful_strings);
		fprintf (out, "# Generated %u string flags\n", successful_strings);
	} else {
		fprintf (stderr, "Could not parse strings\n");
		fprintf (out, "# Could not parse string data\n");
	}

	/* Clean up string parsing resources */
	if (string_infos) {
		free (string_infos);
	}
	if (string_storage) {
		free (string_storage);
	}

	/* Free function names */
	for (u32 i = 0; i < function_count; i++) {
		if (function_names[i]) {
			free (function_names[i]);
		}
	}
	free (function_names);
	free (function_offsets);
	free (function_sizes);

	/* Close output file if needed */
	if (output_file) {
		fclose (out);
		printf ("\n[+] R2 script output wrote to \"%s\"\n\n", output_file);
	}

	/* Clean up */
	hbc_reader_cleanup (&reader);

	return SUCCESS_RESULT ();
}
